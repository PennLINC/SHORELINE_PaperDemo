[{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 SHORELINEPaper authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Head Motion Benchmark","text":"project, used FiberFox simulate entire dMRI series ABCD, HCP, DSIQ5, HASC55 data. Head motion introduced applying rigid transforms streamline data (translations rotations). , QSIPrep used SHORELine Eddy estimate introduced head motion — analysis results evaluated notebook.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"libraries-setup","dir":"Articles","previous_headings":"","what":"Libraries & Setup","title":"Head Motion Benchmark","text":"data available OSF link. package internally downloads cleans convenience. ’re available preprocessed within package:","code":"# for viewing the preprocessed data motion_df <- SHORELINEPaper::motion_df %>%   as_tibble() data(\"error_df_wsetting\") data(\"error_rmse_wsetting\") # for analysis of estimated motion"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"sample","dir":"Articles","previous_headings":"","what":"Sample","title":"Head Motion Benchmark","text":"table shows number b0’s scheme: breakdown runs accumulated: finally total scans volumes: Note errors rotation converted radians degrees, also extract \\(b > 0\\) volumes. Eddy SHORELine use different methods (non-GP non-SHORE) motion-correcting images.","code":"# QUESTION the Num b > 1 seem to be slightly higher and lower than table 1 motion_df %>%   filter(     iternum == 1 &       method == \"SHORELine\" &       denoising == \"none\" &       bval > 100 &       setting == \"Affine\") %>%   group_by(percent_motion, scheme) %>%   summarise(max_b = max(bval),             num_b = n()) %>%   ungroup() %>%   distinct(scheme, max_b, num_b) %>%   t() %>%   row_to_names(1) %>%   data.frame() %>%   add_row(ABCD = \"Shelled\", HCP = \"Shelled\", DSIQ5 = \"Cartesian\", HASC55 = \"Random\", .before = 1) -> tab1 ## `summarise()` has grouped output by 'percent_motion'. You can override using ## the `.groups` argument. rownames(tab1) <- c(\"Type\", \"Max. b\", \"Num. b > 0\")  gt(tab1, rownames_to_stub = TRUE) %>%   tab_header(\"Scheme properties and processing pipeline runs\") %>%   opt_table_font(\"Times New Roman\") motion_df %>%   filter(volnum == 0) %>%   select(Algorithm = method, Model = setting, Denoising = denoising, percent_motion, scheme) %>%   group_by_all() %>%   summarise(n = n()) %>%   pivot_wider(names_from = scheme, values_from = n) %>%   ungroup() %>%   mutate(across(where(is.numeric), ~ ifelse(is.na(.), 0, .))) %>%   mutate(Denoising = ifelse(Denoising == \"none\", \"None\", \"MP-PCA\")) %>%   mutate(percent_motion = paste0(as.character(percent_motion), \" %\")) %>%   # insert empty string for tidyness   mutate(across(where(is.factor), as.character)) %>%   group_by(Algorithm, Model, Denoising) %>%   mutate_at(vars(Algorithm:Denoising), ~ replace(.x, duplicated(.x), \"\")) %>%   ungroup() %>%   select(-Algorithm) %>%   gt() %>%   tab_spanner(\"# Pipeline Runs\", columns = ABCD:HASC55) %>%   cols_align(align = \"right\", columns = percent_motion:HASC55) %>%   tab_row_group(     label = \"Eddy\",     rows = 1:12   ) %>%   tab_row_group(     label = \"SHORELine\",     rows = 13:24   ) %>%   opt_table_font(\"Times New Roman\") ## `summarise()` has grouped output by 'Algorithm', 'Model', 'Denoising', ## 'percent_motion'. You can override using the `.groups` argument. motion_df %>%   filter(volnum == 0) %>%   select(Algorithm = method, Model = setting, Denoising = denoising, percent_motion, scheme) %>%   group_by_all() %>%   summarise(n = n()) %>%   pivot_wider(names_from = scheme, values_from = n) %>%   ungroup() %>%   mutate(across(where(is.numeric), ~ ifelse(is.na(.), 0, .))) %>%   mutate(Denoising = ifelse(Denoising == \"none\", \"None\", \"MP-PCA\")) %>%   mutate(percent_motion = paste0(as.character(percent_motion), \" %\")) %>%   group_by(Algorithm) %>%   summarise(across(ABCD:HASC55,sum)) %>%   gt() %>%   tab_header(\"Total Scans\") %>%   opt_table_font(\"Times New Roman\") ## `summarise()` has grouped output by 'Algorithm', 'Model', 'Denoising', ## 'percent_motion'. You can override using the `.groups` argument. motion_df %>%   filter(bval > 0) %>%   select(Algorithm = method, Model = setting, Denoising = denoising, percent_motion, scheme) %>%   group_by(scheme) %>%   summarise(`Total b > 0 Volumes` = n()) %>%   t() %>%   row_to_names(1) %>%   data.frame() %>%   gt(rownames_to_stub = TRUE) %>%   opt_table_font(\"Times New Roman\")"},{"path":[]},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"is-there-an-rmse-difference-between-the-rigidaffine-and-linearquadratic-settings","dir":"Articles","previous_headings":"Motion Analysis","what":"1. Is there an RMSE difference between the Rigid/Affine and Linear/Quadratic settings?","title":"Head Motion Benchmark","text":"tested Rigid Affine transformation models SHORELine Linear Quadratic models Eddy. Eddy, models affect Eddy current correction shouldn’t see difference head motion estimates. SHORELine may may benefit degrees freedom transformation model. test whether significant effects transformation model. hood R pair scans perform paired t-test subtracting alphabetically. SHORELine means Affine - Rigid Eddy means Linear - Quadratic. can see effects survive filter \\(\\text{Adjusted-}p < 0.01\\) SHORELine estimates positive. means Affine RMSE greater Rigid RMSE. Although estimates tiny, simplify subsequent comparisons choosing rigid. Rigid also benefit much shorter run times Affine. expected, differences Eddy. ’ll subset RMSE values just ’re using rest comparisons:","code":"# TODO put these long functions into a function  # TODO times new roman in the header and stub  setting_tests <- error_rmse_wsetting %>%   rename(hmc_method=method) %>%   group_by(denoising, scheme, motion.type, hmc_method, percent_motion) %>%   do(test = tidy(t.test(rmse ~ setting, data=., paired=TRUE))) %>%   unnest(test)  # Adjust the p-values and order them by the largest absolute effects setting_tests_adj <- setting_tests %>%    select(!c(parameter, method, alternative)) %>%      pivot_wider(     names_from = motion.type,      values_from = c(estimate:conf.high)     ) %>%      # p adjust any pvalues   mutate(     across(       contains(\"p.value\"),        ~p.adjust(.x),       .names = \"Adjusted_{.col}\"       )     ) %>%    # filter sig pvals   # no eddy rows should get through this filter   filter(if_any(contains(\"Adjusted\"), ~.x < 0.01))  setting_tests_adj %>%   select(Method = hmc_method, Scheme = scheme, Denoising = denoising, percent_motion, everything()) %>%         # reorder columns   arrange(Method, Scheme, Denoising) %>%      # convert to char for empty strings &   # insert empty strings for every group where the values are duplicated   # for clarity      mutate(across(where(is.factor), as.character)) %>%     group_by(Method, Scheme, Denoising) %>%   mutate_at(vars(Method:Denoising), ~ replace(.x, duplicated(.x), \"\")) %>%   ungroup() %>%      # precision for the confidence intervals that get merged   mutate(across(contains(\"conf\"), ~ round(.x, 2))) %>%   select(!matches(\"^p.value\")) %>%      # last details   mutate(Denoising = ifelse(Denoising == \"none\", \"None\", \"DWIDenoise\")) %>%         gt(rowname_col = \"Scheme\") -> setting_tests_gt    setting_tests_gt %>%   tab_spanner(label = md(\"*Rotation*\"), columns = matches(\"Rotation\")) %>%   tab_spanner(label = md(\"*Translation*\"), columns = matches(\"Translation\")) %>%      # string format confidence intervals   cols_merge(columns = c(conf.low_Translation, conf.high_Translation), pattern = \"[{1}, {2}]\") %>%   cols_label(     conf.low_Translation = \"95% CI\"   ) %>%   cols_merge(columns = c(conf.low_Rotation, conf.high_Rotation), pattern = \"[{1}, {2}]\") %>%   cols_label(     conf.low_Rotation = \"95% CI\"   ) %>%   fmt(     columns = matches(\"p.value\"),     fns = function(x){       format.pval(x, eps=0.0001, digits = 3)     }   ) %>%   fmt_number(     columns = matches(\"statistic|estimate\"),     decimals = 3   ) %>%   cols_label(     Adjusted_p.value_Rotation = md(\"Adj. *p*-value\"),     Adjusted_p.value_Translation = md(\"Adj. *p*-value\"),     estimate_Rotation = md(\"Estimate\"),     estimate_Translation = md(\"Estimate\"),     statistic_Rotation = md(\"Statistic\"),     statistic_Translation = md(\"Statistic\"),     percent_motion = md(\"% Motion\")   ) %>%      data_color(     columns = c(estimate_Translation, estimate_Rotation),     colors = scales::col_numeric(       palette = rocket(10),       domain = c(-0.1, 0.5)     )   ) %>%   tab_style(     style = list(       cell_text(font = \"Times New Roman\")       ),     locations = cells_body(       columns = everything(),       rows = everything()     )   ) %>%   tab_style(     style = list(       cell_text(weight = \"bold\")       ),     locations = cells_column_labels(columns = everything())   ) %>%   tab_style(     style = list(       cell_text(weight = \"bold\")       ),     locations = cells_column_spanners(spanners = everything())   ) %>%   tab_header(md(\"**Predicting RMSE of Motion Estimates**\"),              subtitle = \"Evaluation of Effects on Transformation\") %>%   opt_table_font(\"Times New Roman\") # Only look at one setting per method error_rmse <- error_rmse_wsetting %>%    filter(setting %in% c(\"Rigid\", \"Quadratic\")) %>%   select(-setting)"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"summarization-of-motion-detection-errors","dir":"Articles","previous_headings":"Motion Analysis","what":"2. Summarization of Motion Detection Errors","title":"Head Motion Benchmark","text":"summarize big errors estimating head motion. first look distribution errors check ’s centered around zero, case eddy shoreline.  Next see standard deviation error . tells us, average, amount degrees mm can expect error method.   means reported paper, also calculated OHBM poster.","code":"# TODO generally improve this plot  error_df_wsetting %>%   select(method, scheme, denoising, percent_motion, motion.type, Error = value) %>%   filter(Error < 20 & Error > -20) %>% # very egregious errors   mutate(percent_motion = ordered(percent_motion, levels=c(50, 30, 15))) %>%   ggplot(aes(x=Error, y=percent_motion, fill=scheme)) +   stat_slab(alpha = 0.5, width = 0, .width = 0, point_colour = NA, expand=TRUE, color = \"black\") +   facet_grid(method ~ motion.type, scales = \"free\") +   ggtitle(\"Distribution of Motion Estimate Errors\") # TODO put formatting into a function  rmse_summaries <- error_rmse %>%   group_by(denoising, scheme, motion.type, method, percent_motion) %>%   summarise(mean_rmse=mean(rmse),              sd_rmse=sd(rmse),              se_rmse=sd_rmse/sqrt(length(rmse)),             group_mean_error=mean(mean_error),             sd_mean_error=sd(mean_error)) ## `summarise()` has grouped output by 'denoising', 'scheme', 'motion.type', ## 'method'. You can override using the `.groups` argument. rmse_summaries <- rmse_summaries %>%   mutate(     motion.type = case_when(       str_detect(motion.type, \"Rotation\")  ~ \"Rotation (degrees)\",       str_detect(motion.type, \"Translation\")  ~ \"Translation (mm)\"       ),     Denoising=case_when(denoising == \"none\"  ~ \"None\", TRUE ~ \"MP-PCA\") %>% factor()        )  pd=position_dodge2(width=0.7, preserve=\"single\") linetypes = c(\"None\" = 1, \"MP-PCA\" = 2)  error_mean_plt <-  ggplot(     rmse_summaries,     aes(       y=group_mean_error, x=percent_motion,        fill=method, group=Denoising)     ) +   geom_bar(aes(alpha=Denoising), stat=\"identity\", position=pd, width = 0.6) +   geom_errorbar(     aes(ymax=group_mean_error+mean_rmse,         ymin=group_mean_error-mean_rmse,         width=0.7),     color = \"black\", position=pd     ) +   facet_grid(motion.type~scheme, scales=\"free\") +    scale_color_manual(     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\"), guide=\"none\"     ) +   scale_fill_manual(     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")     ) +   scale_alpha_manual(     name=\"Denoising Strategy\",     values=c(1.0, 0.5)     ) +   theme_bw(     base_family=\"Helvetica\",     base_size=12   ) +   labs(title = \"Head Motion Estimate Error\",         y = \"Mean Error (±Mean RMSE)\",         x = \"Percent Motion Volumes\",         fill = \"Method\"        ) +   guides(linetype=guide_legend(override.aes=list(fill=NA))) # TODO reduce plot size, increase font size error_mean_plt # Summarize the motion rmse in the different cells # rmse_plt <-  ggplot( #     rmse_summaries, #     aes( #       y=mean_rmse, x=percent_motion,  #       color=method, fill=method) #     ) + #   geom_bar(aes(alpha=Denoising), stat=\"identity\", position=pd, width = 0.6) + #   geom_errorbar( #     aes(ymax=mean_rmse+sd_rmse, ymin=mean_rmse-sd_rmse, #         width=0.6), #     color = \"black\", position=pd #     ) + #   facet_grid(motion.type~scheme, scales=\"free\") +  #   scale_color_manual( #     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\"), guide=\"none\" #     ) + #   scale_fill_manual( #     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\") #     ) + #   scale_alpha_manual( #     name=\"Denoising Strategy\", #     values=c(1.0, 0.5) #     ) + #   theme_bw( #     base_family=\"Helvetica\", #     base_size=12 #   ) + #   labs(title = \"Motion Estimate RMSE\", #        y = \"Mean RMSE (±SD)\",  #        x = \"Percent Motion Volumes\",  #        fill = \"Method\", #        ) + #   guides(linetype=guide_legend(override.aes=list(fill=NA)))   rmse_plt <-  ggplot(     rmse_summaries,     aes(       y=mean_rmse, x=percent_motion,        fill=method, group=Denoising)     ) +   geom_bar(aes(alpha=Denoising), stat=\"identity\", position=pd, width = 0.6) +   geom_errorbar(     aes(ymax=mean_rmse+sd_rmse, ymin=mean_rmse-sd_rmse,         width=0.6),     color = \"black\", position=pd     ) +   facet_grid(motion.type~scheme, scales=\"free\") +    scale_fill_manual(     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")     ) +   scale_alpha_manual(     name=\"Denoising Strategy\",     values=c(1.0, 0.5)     ) +   theme_bw(     base_family=\"Helvetica\",     base_size=12   ) +   labs(title = \"Motion Estimate RMSE\",        y = \"Mean RMSE (±SD)\",         x = \"Percent Motion Volumes\",         fill = \"Method\",        ) +   guides(linetype=guide_legend(override.aes=list(fill=NA))) rmse_plt # TODO formatting errs <- error_rmse %>% group_by(motion.type) %>%    summarise(mean_mean_error=mean(mean_error),             sd_mean_error=sd(mean_error))  errs %>%   gt() %>%   tab_header(\"Mean RMSE by Motion Type\") %>%   opt_table_font(\"Times New Roman\")"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"compare-performance-on-sampling-schemes","dir":"Articles","previous_headings":"Motion Analysis","what":"3. Compare Performance on Sampling Schemes","title":"Head Motion Benchmark","text":"4 sampling schemes compared . well motion correction methods work ?  just another view previous plot, interesting clearly shows SHORELine’s performance 55-direction CS-DSI scan range performance ABCD multi shell scheme, almost twice many directions. can statistically test , sure: couple interesting results come along obvious ones. First, main effect number directions. directions, smaller RMSE.","code":"rmse_summaries_collapsed <- error_rmse %>%   group_by(scheme, motion.type, method, denoising) %>%   summarise(mean_rmse=mean(rmse),              sd_rmse=sd(rmse),              se_rmse=sd_rmse/sqrt(length(rmse)),             group_mean_error=mean(mean_error),             sd_mean_error=sd(mean_error)) %>%   mutate(denoised = recode(denoising, none=\"\", dwidenoise=\"+ MP-PCA\"),          method_name = paste(method, denoised)) %>%   select(-denoised) %>%   filter(method_name != \"SHORELine + MP-PCA\") # no difference, so skip it ## `summarise()` has grouped output by 'scheme', 'motion.type', 'method'. You can ## override using the `.groups` argument. rmse_summaries_collapsed %>%   ungroup() %>%   mutate(     num_directions = case_when(       scheme == \"ABCD\"    ~ 103,       scheme == \"HCP\"     ~ 270,       scheme == \"DSIQ5\"   ~ 257,       scheme == \"HASC55\"  ~ 55     )   ) %>% # rmse_summaries_collapsed$num_directions <- recode( #   rmse_summaries_collapsed$scheme, #   ABCD=103, #   HCP=270, #   DSIQ5=257, #   HASC55=55)    mutate(     denoiser = case_when(       denoising == \"none\" ~ \"None\",       TRUE                ~ \"MP-PCA\"     )   ) %>% # rmse_summaries_collapsed$denoiser <- recode( #   rmse_summaries_collapsed$denoising, #   none=\"None\", #   dwidenoise=\"MP-PCA\" # )    mutate(     scheme_type = case_when(       str_detect(scheme, \"ABCD|HCP\")  ~ \"Shelled\",       TRUE                            ~ \"Non-Shelled\"     )   ) %>%    # rmse_summaries_collapsed$scheme_type = recode( #   rmse_summaries_collapsed$scheme, #   ABCD=\"Shelled\", #   HCP=\"Shelled\", #   DSIQ5=\"Non-Shelled\", #   HASC55=\"Non-Shelled\")    mutate(     motion.type = case_when(       str_detect(motion.type, \"Rotation\")     ~ \"Rotation (degrees)\",       str_detect(motion.type, \"Translation\")  ~ \"Tranlation (mm)\",     )   ) -> rmse_summaries_collapsed # rmse_summaries_collapsed$motion.type <- recode( #   rmse_summaries_collapsed$motion.type, #   Rotation=\"Rotation (degrees)\", #   Translation=\"Translation (mm)\" #   )  # Summarize the motion rmse in the different cells pd2 = position_dodge(8) directions_plt <-  ggplot(     rmse_summaries_collapsed,     aes(x=num_directions, y=mean_rmse,         color=method,         shape=scheme_type,         linetype=denoiser,         group=method_name)) +   geom_errorbar(     aes(ymax=mean_rmse+sd_rmse, ymin=mean_rmse-sd_rmse),      position=pd2) +   geom_point(size=2, position=pd2) +   geom_line() +   facet_grid(motion.type~.) +   theme_bw(     base_family=\"Helvetica\",     base_size=12   ) +   scale_color_manual(     labels=c(\"SHORELine\", \"Eddy\"),     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")) +   scale_linetype_manual(values=c(\"None\"=1,\"MP-PCA\" = 2)) +   labs(title = \"RMSE by Scheme Type\",         y = \"Mean RMSE (±SD)\",         x = \"Number of Directions\",         color = \"Method\",        linetype= \"Denoising\\nMethod\",        shape=\"Scheme\\nType\") directions_plt error_rmse_dirs <- error_rmse  error_rmse_dirs$num_directions <- recode(   error_rmse_dirs$scheme,   ABCD=103,   HCP=270,   DSIQ5=257,   HASC55=55)  error_rmse_dirs$scheme_type = recode(   error_rmse_dirs$scheme,   ABCD=\"Shelled\",   HCP=\"Shelled\",   DSIQ5=\"Non-Shelled\",   HASC55=\"Non-Shelled\")  # Convert to percentage values error_rmse_dirs$percent_motion <- with(   error_rmse_dirs,   as.numeric(levels(percent_motion))[percent_motion])  # run lm rotation_shell_model <- lm(   rmse ~ scheme_type * num_directions + denoising + percent_motion,   data=subset(error_rmse_dirs, motion.type==\"Rotation\"))  translation_shell_model <- lm(   rmse ~ scheme_type * num_directions + denoising + percent_motion,   data=subset(error_rmse_dirs, motion.type==\"Translation\")) # create gt tables translation_rmse_tab <- tbl_regression(   translation_shell_model,    intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels()  rotation_rmse_tab <- tbl_regression(   rotation_shell_model,    intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels() # merge and display  rmse_model_table <- tbl_merge(list(translation_rmse_tab, rotation_rmse_tab), tab_spanner = c(\"Translation\", \"Rotation\")) %>%   as_gt() %>%   fmt_number(n_sigfig = 2, matches(\"Beta\"), force_sign = TRUE) %>%   tab_header(title = \"RMSE of Predicted Motion\",              subtitle = \"Main Effects of Denoising, Number of Directions, and Percent Motion, including interactions with Shell Scheme\") %>%   #tab_source_note(md(\"*This data is simulated*\")) %>%   opt_table_font(\"Helvetica\") ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead rmse_model_table %>% gtsave(\"rmse_model.pdf\", zoom=1)"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"head-to-head-comparison-of-shoreline-vs-eddy","dir":"Articles","previous_headings":"Motion Analysis","what":"4 Head to head comparison of SHORELine vs Eddy","title":"Head Motion Benchmark","text":"ABCD HCP sequences two schemes tested can processed Eddy SHORELine. plot RMSE differences:","code":"# Match the Eddy and SHORELine errors  paired_error <- error_rmse %>%   select(-mean_error, -sd_error) %>%   filter(scheme %in% c(\"ABCD\", \"HCP\")) %>%   spread(method, rmse, sep=\"_\") %>%    group_by(scheme, motion.type) %>%    mutate(shore_difference=method_Eddy - method_SHORELine,          percent_motion=as.numeric(levels(percent_motion))[percent_motion])  rotation_rmse_model_paired <- lm(   shore_difference ~ scheme * denoising * percent_motion,   data=subset(paired_error, motion.type==\"Rotation\"))  translation_rmse_model_paired <- lm(   shore_difference ~ scheme * denoising * percent_motion,   data=subset(paired_error, motion.type==\"Translation\")) translation_rmse_paired_tab <- tbl_regression(   translation_rmse_model_paired,    intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels()  rotation_rmse_paired_tab <- tbl_regression(   rotation_rmse_model_paired,    intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels() tbl_merge(list(translation_rmse_paired_tab, rotation_rmse_paired_tab), tab_spanner = c(\"Translation\", \"Rotation\")) %>%   as_gt() %>%   fmt_number(n_sigfig = 2, matches(\"Beta\"), force_sign = TRUE) %>%   tab_header(title = \"Predicting RMSE Difference (Eddy — SHORELine) in ABCD & HCP Schemes\",              subtitle = \"Main Effects of Denoising & Percent Motion, and interactions with Shell Scheme\") %>%   tab_source_note(md(\"*This data is simulated*\")) %>%   tab_footnote(escape_latex(md(\"The SHORELine RMSE value was subtracted from the Eddy RMSE from each simulated scan, and this difference was the outcome variable of the model. Positive Beta estimates suggest better performance by SHORELine.\")),                locations = cells_title(\"title\")) %>%   opt_table_font(\"Times New Roman\") ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead ggplot(paired_error,         aes(x=as.factor(percent_motion),             y=shore_difference,            fill=denoising)) +   stat_halfeye(     justification = -.2,     alpha = 0.8,     .width = 0,      point_colour = NA) +   geom_boxplot(     width = .12,      outlier.shape = NA ## `outlier.shape = NA` works as well   ) +   # geom_point(   #   ## draw horizontal lines instead of points   #   shape = 95,   #   size = 10,   #   alpha = 0.2,   # ) +   coord_cartesian(xlim = c(1.2, NA)) +   facet_grid(motion.type~scheme, scales=\"free\") +   scale_fill_manual(     labels=c(\"MP-PCA\", \"None\"),     values=c(\"dwidenoise\"=\"#FFC20A\", \"none\"=\"#0C7BDC\")) +   theme_bw(     base_family=\"Helvetica\",     base_size=12) +   labs(     title = \"Differences in Estimate Error (Eddy - SHORELine)\",     y = \"Estimation Error Difference\",     x = \"Percent Motion Volumes\",     fill=\"Denoising\\nMethod\")"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"qc-metric-comparisons-between-shoreline-and-eddy","dir":"Articles","previous_headings":"","what":"QC metric comparisons between SHORELine and Eddy","title":"Head Motion Benchmark","text":"accurately estimating head motion parameters important, head motion artifact present simulated data. factors like eddy current distortion can impact final quality results. therefore calculated compared Neighboring DWI Correlation (NDC) FWHM final outputs two methods. NDC FWHM results related, used method Cieslak et al. 2021 FWHM partialled NDC measurements.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"test-the-settings","dir":"Articles","previous_headings":"QC metric comparisons between SHORELine and Eddy","what":"1. Test the Settings","title":"Head Motion Benchmark","text":"tested settings see Linear/Quadratic Rigid/Affine made difference motion estimation accuracy. Linear/Quadratic showed difference, Rigid performed better Affine. Recall ’re testing NDC, better higher. t-tests work way : significant effects SHORELine estimates positive. means Affine NDC higher Rigid NDC. Although effects absolutely tiny, different direction RMSE tests: Affine produces higher QC metrics Rigid, Rigid accurate estimating head motion Affine. consistent tests, use Rigid QC comparisons. Rigid also remarkably faster Affine, first step powerful Eddy Current correction later.","code":"data(\"qc_df\") setting_tests <- qc_df %>%   rename(hmc_method=method) %>%   group_by(denoising, scheme, hmc_method, percent_motion) %>%   do(test = tidy(t.test(ndc.corrected ~ setting, data=., paired=TRUE))) %>%   unnest(test)  # Adjust the p-values and order them by the largest absolute effects setting_tests <- setting_tests %>%   mutate(p.value.adj = p.adjust(p.value)) #  # significant.effects <- subset(setting_tests, (p.value.adj < 0.01)) # significant.effects[order(-abs(significant.effects$estimate)),]  setting_tests_gt <- setting_tests %>%    select(!c(parameter, method, alternative)) %>%   select(Method = hmc_method, Scheme = scheme, Denoising = denoising, percent_motion, everything()) %>%   arrange(Method, Scheme, Denoising) %>%      # convert to char for empty strings &   # insert empty strings for every group where the values are duplicated   # for clarity      mutate(across(where(is.factor), as.character)) %>%     group_by(Method, Scheme, Denoising) %>%   mutate_at(vars(Method:Denoising), ~ replace(.x, duplicated(.x), \"\")) %>%   ungroup() %>%      # precision for the confidence intervals that get merged   mutate(across(contains(\"conf\"), ~ round(.x, 2))) %>%      # last details   mutate(Denoising = ifelse(Denoising == \"none\", \"None\", \"DWIDenoise\")) %>%   select(-p.value) %>%   mutate(pval_marker = p.value.adj) %>%   mutate(percent_motion = paste0(as.character(percent_motion), \" %\")) %>%      gt(rowname_col = \"Scheme\") setting_tests_gt %>%   cols_merge(columns = c(conf.low, conf.high), pattern = \"[{1}, {2}]\") %>%   cols_label(     conf.low = \"95% CI\"   ) %>%   fmt(     columns = matches(\"p.value.adj\"),     fns = function(x){       format.pval(x, eps=0.0001, digits = 3)     }   ) %>%   tab_style(     style = list(       cell_text(weight = \"bold\")       ),     locations = cells_body(columns = p.value.adj, rows = pval_marker < 0.01)   ) %>%   fmt_number(     columns = matches(\"statistic|estimate\"),     decimals = 3   ) %>%   cols_label(     p.value.adj = md(\"Adj. *p*-value\"),     estimate = md(\"Estimate\"),     statistic = md(\"Statistic\"),     percent_motion = md(\"% Motion\")   ) %>%   tab_style(     style = list(       cell_text(weight = \"bold\")       ),     locations = cells_column_labels(columns = everything())   ) %>%   opt_table_font(\"Times New Roman\") qc_df <- qc_df %>%    ungroup() %>%   filter(setting %in% c(\"Rigid\", \"Quadratic\")) %>%   select(-setting)"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"how-does-the-fwhm-compare","dir":"Articles","previous_headings":"QC metric comparisons between SHORELine and Eddy","what":"2. How does the fwhm compare?","title":"Head Motion Benchmark","text":"","code":"fwhm_smooth_plot <- qc_df %>%   ggplot(aes(x=factor(percent_motion), y=fwhm, fill=method)) +   stat_halfeye(     justification = -.2,     alpha = 0.8,     .width = 0,      point_colour = NA) +   geom_boxplot(     position = position_dodge2(width = 5, preserve = \"single\", padding= 0.02),     width = .12,     alpha = 0.8,     outlier.shape = NA ## `outlier.shape = NA` works as well   ) +    scale_fill_manual(     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")) +   theme_bw(     base_family=\"Times\",     base_size=12   ) +   labs(title = \"Spatial Smoothness (FWHM)\",         y = \"FWHM (mm)\",         x = \"Percent Motion Volumes\",         fill = \"Method\") +   facet_wrap(~scheme, ncol=2) fwhm_smooth_plot ggsave(here(\"vignettes\",\"fwhm_smooth_plot.svg\"),        plot=fwhm_smooth_plot,        height=3,        width=7.9,        units=\"in\") # What about if we make a paired comparison? id_cols <- c(\"scheme\", \"iternum\", \"method\", \"denoising\", \"percent_motion\")  paired_fwhm <- qc_df %>%    select(one_of(c(id_cols, \"fwhm\"))) %>%   spread(method, fwhm, sep=\"_\") %>%   mutate(fwhm_diff=method_SHORELine - method_Eddy,          percent_motion = as.factor(percent_motion)) %>%   select(-starts_with(\"method_\")) fwhm_diff_model <- lm(   fwhm_diff ~ percent_motion + scheme + denoising,   data=paired_fwhm) tbl_regression(   fwhm_diff_model,   intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels() %>%   as_gt() %>%   tab_header(title = \"Linear Model Predicting FWHM (Eddy — Shoreline) of Each Scan\",              subtitle = \"Main Effects of Percent Motion, Scheme, and Denoising\") %>%   tab_source_note(md(\"*This data is simulated*\")) %>%   opt_table_font(\"Times New Roman\") ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"comparing-fwhm-corrected-ndc-between-shoreline-and-eddy","dir":"Articles","previous_headings":"QC metric comparisons between SHORELine and Eddy","what":"3. Comparing FWHM-corrected NDC between SHORELine and Eddy","title":"Head Motion Benchmark","text":"one methods higher NDC scores? Also improvement NDC relative raw data? know higher percent motion cause lower NDC scores unprocessed data.  NDC scores don’t mean much across sampling schemes, comparable within sampling schemes. top row shows MP-PCA improves NDC scores across board also Eddy small advantage two shelled schemes can used. second row shows percent improvement NDC relative raw scans. pretty remarkable. statistical tests, center raw NDC within percent motion category","code":"improved_ndc_summaries <- qc_df %>%   group_by(denoising, scheme, method, percent_motion) %>%   summarise(mean_ndc=mean(improved.ndc.corrected),              sd_ndc=sd(improved.ndc.corrected),              se_ndc=sd_ndc/sqrt(length(improved.ndc.corrected)),             group_mean_ndc=mean(mean_ndc),             sd_mean_ndc=sd(mean_ndc)) ## `summarise()` has grouped output by 'denoising', 'scheme', 'method'. You can ## override using the `.groups` argument. improved_ndc_summaries$measure <- 'NDC Change\\nFrom Raw' ndc_summaries <- qc_df %>%   group_by(denoising, scheme, method, percent_motion) %>%   summarise(mean_ndc=mean(ndc.corrected),              sd_ndc=sd(ndc.corrected),              se_ndc=sd_ndc/sqrt(length(ndc.corrected)),             group_mean_ndc=mean(mean_ndc),             sd_mean_ndc=sd(mean_ndc)) ## `summarise()` has grouped output by 'denoising', 'scheme', 'method'. You can ## override using the `.groups` argument. ndc_summaries$measure <- 'Preprocessed NDC' qc_summaries <- rbind(ndc_summaries, improved_ndc_summaries) qc_summaries$percent_motion <- as.factor(qc_summaries$percent_motion) qc_summaries$measure <- factor(qc_summaries$measure, levels=c('Preprocessed NDC', 'NDC Change\\nFrom Raw')) pd=position_dodge(width=0.6, preserve=\"single\") ndc_mean_plt <-     ggplot(     qc_summaries,     aes(       y=group_mean_ndc, x=percent_motion,        fill=method, group=interaction(method, denoising))     ) +   geom_bar(aes(alpha=denoising), stat=\"identity\", position=pd, width = 0.6) +   geom_errorbar(     aes(ymax=group_mean_ndc+sd_ndc, ymin=group_mean_ndc-sd_ndc,         width=0.6),     color = \"black\", position=pd     ) +   facet_grid(measure~scheme, scales=\"free\") +   scale_fill_manual(     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")     ) +   scale_alpha_manual(     name=\"Denoising Strategy\",     values=c(1.0, 0.5)     ) +   theme_bw(     base_family=\"Helvetica\",     base_size=12   ) +   theme(strip.text.y = element_text(size = 8)) +   labs(title = \"QC Measure\",         y = \"Neighboring DWI Correlation\",         x = \"Percent Motion Volumes\",        fill = \"Method\"        ) +   guides(linetype=guide_legend(override.aes=list(fill=NA))) ndc_mean_plt ggsave(here(\"vignettes\",\"ndc_mean_plot.svg\"),        plot=ndc_mean_plt,        height=3.5,        width=7.9,        units=\"in\") qc_df <- subset(qc_df, scheme %in% c(\"ABCD\", \"HCP\"))  ggplot(qc_df, aes(x=percent_motion, y=raw_neighbor_corr, color=scheme)) +    geom_jitter() +   ggtitle(\"Unprocessed data NDC values\") qc_df <- qc_df %>%    group_by(percent_motion) %>%    mutate(pct_motion_mean=median(raw_neighbor_corr),           centered_raw_ndc=raw_neighbor_corr - pct_motion_mean)  ggplot(qc_df, aes(x=percent_motion, y=centered_raw_ndc, color=scheme)) +    geom_jitter() +   ggtitle(\"Unprocessed data NDC values: Centered by percent motion\") paired_ndc <- qc_df %>%    select(one_of(c(id_cols, \"ndc.corrected\"))) %>%   spread(method, ndc.corrected, sep=\"_\") %>%   mutate(ndc_diff=method_SHORELine - method_Eddy) %>%   select(-starts_with(\"method_\"))  ndc_diff_model <- lm(   ndc_diff ~ percent_motion + denoising + scheme,   data=paired_ndc) tbl_regression(   ndc_diff_model,   intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels() %>%   as_gt() %>%   tab_header(title = \"NDC Model\") %>%   tab_source_note(md(\"*This data is simulated*\")) %>%   opt_table_font(\"Times\") ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead  ## Warning: The `fmt_missing()` function is deprecated and will soon be removed ## * Use the `sub_missing()` function instead"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tinashe Tapera. Maintainer.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Tapera T (2022). SHORELINEPaper: SHORELINE Benchmarking Documentation. R package version 0.0.0.9000, https://pennlinc.github.io/SHORELINE_PaperDemo/.","code":"@Manual{,   title = {SHORELINEPaper: SHORELINE Benchmarking Documentation},   author = {Tinashe Tapera},   year = {2022},   note = {R package version 0.0.0.9000},   url = {https://pennlinc.github.io/SHORELINE_PaperDemo/}, }"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/index.html","id":"shoreline-paper-reproducible-analysis","dir":"","previous_headings":"","what":"SHORELINE Benchmarking Documentation","title":"SHORELINE Benchmarking Documentation","text":"package developed reproduce, document, share results SHORELINE benchmarking paper developed Matt Cieslak Penn Lifespan Informatics & Neuroimaging Center (manuscript preparation). abstract paper reads follows: Head motion correction particularly challenging diffusion-weighted MRI (dMRI) scans due dramatic changes image contrast different gradient strengths directions. Currently head motion correction typically performed using Gaussian Process model implemented FSL’s Eddy. Recently, 3dSHORE-based SHORELine method introduced correct non-single-shelled sequence. perform comprehensive evaluation methods realistic simulations software fiber phantom known ground-truth head motion. demonstrate methods perform remarkably well, performance can affected sampling scheme, pervasiveness head motion denoising strategy applied head motion correction. package specifically documents statistical analysis portion paper. Articles, ’ll find Rmarkdown file produces statistical analysis dataset; walkthrough analyses performed; code producing visualizations table content. Dense code preprocessing datasets also available /R folder. can also reproduce analyses downloading package remotes::install_github(\"PennLINC/SHORELINE_PaperDemo\") emulating Article, online using Binder.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""}]
