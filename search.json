[{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 SHORELINEPaper authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Head Motion Benchmark","text":"project, used FiberFox simulate entire dMRI series ABCD, HCP, DSIQ5, HASC55 data. Head motion introduced applying rigid transforms streamline data (translations rotations). , QSIPrep used SHORELine Eddy estimate introduced head motion — analysis results evaluated notebook.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"libraries-setup","dir":"Articles","previous_headings":"","what":"Libraries & Setup","title":"Head Motion Benchmark","text":"data available OSF link. package internally downloads cleans convenience. ’re available preprocessed within package:","code":"# for viewing the preprocessed data motion_df <- SHORELINEPaper::motion_df %>%   as_tibble()  data(\"error_rmse_wsetting\") # for analysis of estimated motion"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"sample","dir":"Articles","previous_headings":"","what":"Sample","title":"Head Motion Benchmark","text":"table shows number b0’s scheme: breakdown runs accumulated: finally total scans volumes: Note errors rotation converted radians degrees, also extract \\(b > 0\\) volumes. Eddy SHORELine use different methods (non-GP non-SHORE) motion-correcting images.","code":"# QUESTION the Num b > 1 seem to be slightly higher and lower than table 1 motion_df %>%   filter(     iternum == 1 &       method == \"SHORELine\" &       denoising == \"none\" &       bval > 100 &       setting == \"Affine\") %>%   group_by(percent_motion, scheme) %>%   summarise(max_b = max(bval),             num_b = n()) %>%   ungroup() %>%   distinct(scheme, max_b, num_b) %>%   t() %>%   row_to_names(1) %>%   data.frame() %>%   add_row(ABCD = \"Shelled\", HCP = \"Shelled\", DSIQ5 = \"Cartesian\", HASC55 = \"Random\", .before = 1) -> tab1 ## `summarise()` has grouped output by 'percent_motion'. You can override using ## the `.groups` argument. rownames(tab1) <- c(\"Type\", \"Max. b\", \"Num. b > 0\")  gt(tab1, rownames_to_stub = TRUE) %>%   tab_header(\"Scheme properties and processing pipeline runs\") motion_df %>%   filter(volnum == 0) %>%   select(Algorithm = method, Model = setting, Denoising = denoising, percent_motion, scheme) %>%   group_by_all() %>%   summarise(n = n()) %>%   pivot_wider(names_from = scheme, values_from = n) %>%   ungroup() %>%   mutate(across(where(is.numeric), ~ ifelse(is.na(.), 0, .))) %>%   mutate(Denoising = ifelse(Denoising == \"none\", \"None\", \"MP-PCA\")) %>%   mutate(percent_motion = paste0(as.character(percent_motion), \" %\")) %>%   # insert empty string for tidyness   mutate(across(where(is.factor), as.character)) %>%   group_by(Algorithm, Model, Denoising) %>%   mutate_at(vars(Algorithm:Denoising), ~ replace(.x, duplicated(.x), \"\")) %>%   ungroup() %>%   select(-Algorithm) %>%   gt() %>%   tab_spanner(\"# Pipeline Runs\", columns = ABCD:HASC55) %>%   cols_align(align = \"right\", columns = percent_motion:HASC55) %>%   tab_row_group(     label = \"Eddy\",     rows = 1:12   ) %>%   tab_row_group(     label = \"SHORELine\",     rows = 13:24   ) ## `summarise()` has grouped output by 'Algorithm', 'Model', 'Denoising', ## 'percent_motion'. You can override using the `.groups` argument. motion_df %>%   filter(volnum == 0) %>%   select(Algorithm = method, Model = setting, Denoising = denoising, percent_motion, scheme) %>%   group_by_all() %>%   summarise(n = n()) %>%   pivot_wider(names_from = scheme, values_from = n) %>%   ungroup() %>%   mutate(across(where(is.numeric), ~ ifelse(is.na(.), 0, .))) %>%   mutate(Denoising = ifelse(Denoising == \"none\", \"None\", \"MP-PCA\")) %>%   mutate(percent_motion = paste0(as.character(percent_motion), \" %\")) %>%   group_by(Algorithm) %>%   summarise(across(ABCD:HASC55,sum)) %>%   gt() %>%   tab_header(\"Total Scans\") ## `summarise()` has grouped output by 'Algorithm', 'Model', 'Denoising', ## 'percent_motion'. You can override using the `.groups` argument. motion_df %>%   filter(bval > 0) %>%   select(Algorithm = method, Model = setting, Denoising = denoising, percent_motion, scheme) %>%   group_by(scheme) %>%   summarise(`Total b > 0 Volumes` = n()) %>%   t() %>%   row_to_names(1) %>%   data.frame() %>%   gt(rownames_to_stub = TRUE)"},{"path":[]},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"is-there-an-rmse-difference-between-the-rigidaffine-and-linearquadratic-settings","dir":"Articles","previous_headings":"Motion Analysis","what":"1. Is there an RMSE difference between the Rigid/Affine and Linear/Quadratic settings?","title":"Head Motion Benchmark","text":"tested Rigid Affine transformation models SHORELine Linear Quadratic models Eddy. Eddy, models affect Eddy current correction shouldn’t see difference head motion estimates. SHORELine may may benefit degrees freedom transformation model. test whether significant effects transformation model. hood R pair scans perform paired t-test subtracting alphabetically. SHORELine means Affine - Rigid Eddy means Linear - Quadratic. can see effects survive filter SHORELine estimates positive. means Affine RMSE greater Rigid RMSE. Although estimates tiny, simplify subsequent comparisons choosing rigid. Rigid also benefit much shorter run times Affine. expected, differences Eddy. section subsets RMSE values just ’re using rest comparisons:","code":"setting_tests <- error_rmse_wsetting %>%   rename(hmc_method=method) %>%   group_by(denoising, scheme, motion.type, hmc_method, percent_motion) %>%   do(test = tidy(t.test(rmse ~ setting, data=., paired=TRUE))) %>%   unnest(test)  # Adjust the p-values and order them by the largest absolute effects setting_tests_adj <- setting_tests %>%    select(!c(parameter, method, alternative)) %>%      pivot_wider(     names_from = motion.type,      values_from = c(estimate:conf.high)     ) %>%      # p adjust any pvalues   mutate(     across(       contains(\"p.value\"),        ~p.adjust(.x),       .names = \"Adjusted_{.col}\"       )     ) %>%    # filter sig pvals   # no eddy rows should get through this filter   filter(if_any(contains(\"Adjusted\"), ~.x < 0.01))  setting_tests_adj %>%   select(Method = hmc_method, Scheme = scheme, Denoising = denoising, percent_motion, everything()) %>%         # reorder columns   arrange(Method, Scheme, Denoising) %>%      # convert to char for empty strings &   # insert empty strings for every group where the values are duplicated   # for clarity      mutate(across(where(is.factor), as.character)) %>%     group_by(Method, Scheme, Denoising) %>%   mutate_at(vars(Method:Denoising), ~ replace(.x, duplicated(.x), \"\")) %>%   ungroup() %>%      # precision for the confidence intervals that get merged   mutate(across(contains(\"conf\"), ~ round(.x, 2))) %>%   select(!matches(\"^p.value\")) %>%      # last details   mutate(Denoising = ifelse(Denoising == \"none\", \"None\", \"DWIDenoise\")) %>%         gt(rowname_col = \"Scheme\") -> setting_tests_gt    setting_tests_gt %>%   tab_spanner(label = md(\"*Rotation*\"), columns = matches(\"Rotation\")) %>%   tab_spanner(label = md(\"*Translation*\"), columns = matches(\"Translation\")) %>%      # string format confidence intervals   cols_merge(columns = c(conf.low_Translation, conf.high_Translation), pattern = \"[{1}, {2}]\") %>%   cols_label(     conf.low_Translation = \"95% CI\"   ) %>%   cols_merge(columns = c(conf.low_Rotation, conf.high_Rotation), pattern = \"[{1}, {2}]\") %>%   cols_label(     conf.low_Rotation = \"95% CI\"   ) %>%   fmt(     columns = matches(\"p.value\"),     fns = function(x){       format.pval(x, eps=0.0001, digits = 3)     }   ) %>%   fmt_number(     columns = matches(\"statistic|estimate\"),     decimals = 3   ) %>%   cols_label(     Adjusted_p.value_Rotation = md(\"Adj. *p*-value\"),     Adjusted_p.value_Translation = md(\"Adj. *p*-value\"),     estimate_Rotation = md(\"Estimate\"),     estimate_Translation = md(\"Estimate\"),     statistic_Rotation = md(\"Statistic\"),     statistic_Translation = md(\"Statistic\"),     percent_motion = md(\"% Motion\")   ) %>%      data_color(     columns = c(estimate_Translation, estimate_Rotation),     colors = scales::col_numeric(       palette = rocket(10),       domain = c(-0.1, 0.5)     )   ) %>%   tab_style(     style = list(       cell_text(font = \"Times New Roman\")       ),     locations = cells_body(       columns = everything(),       rows = everything()     )   ) %>%   tab_style(     style = list(       cell_text(weight = \"bold\")       ),     locations = cells_column_labels(columns = everything())   ) %>%   tab_style(     style = list(       cell_text(weight = \"bold\")       ),     locations = cells_column_spanners(spanners = everything())   ) %>%   opt_table_font(\"Times New Roman\") %>%   tab_header(md(\"**Predicting RMSE of Motion Estimates**\"),              subtitle = \"Evaluation of Effects on Transformation\") # Only look at one setting per method error_rmse <- error_rmse_wsetting %>%    filter(setting %in% c(\"Rigid\", \"Quadratic\")) %>%   select(-setting)"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"summarization-of-motion-detection-errors","dir":"Articles","previous_headings":"Motion Analysis","what":"2. Summarization of Motion Detection Errors","title":"Head Motion Benchmark","text":"summarize big errors estimating head motion. first look distribution errors check ’s centered around zero. case eddy shoreline. Next see standard deviation error . tells us, average, amount degrees mm can expect error method. means reported paper, also calculated OHBM poster.","code":"rmse_summaries <- error_rmse %>%   group_by(denoising, scheme, motion.type, method, percent_motion) %>%   summarise(mean_rmse=mean(rmse),              sd_rmse=sd(rmse),              se_rmse=sd_rmse/sqrt(length(rmse)),             group_mean_error=mean(mean_error),             sd_mean_error=sd(mean_error)) ## `summarise()` has grouped output by 'denoising', 'scheme', 'motion.type', ## 'method'. You can override using the `.groups` argument. rmse_summaries <- rmse_summaries %>%   mutate(motion.type = case_when(     str_detect(motion.type, \"Rotation\")  ~ \"Rotation (degrees)\",     str_detect(motion.type, \"Translation\")  ~ \"Translation (mm)\",   ))  pd=position_dodge(width=0.7, preserve=\"single\")  error_mean_plt <-  ggplot(     rmse_summaries,     aes(x=percent_motion, y=group_mean_error,          fill=method#, pattern_alpha=denoising         )) +   #scale_pattern_type_discrete(choices=c(\"hatch\")) +   # geom_col_pattern(position=pd,   #                  width=0.5,   #                  pattern_spacing=0.03,   #                  pattern_fill=\"black\",   #                  color=\"black\") +     geom_col(#position=pd,                    #width=0.5,                    #pattern_spacing=0.03,                    #pattern_fill=\"black\",                    #color=\"black\"              ) +   # scale_pattern_alpha_discrete(   #   range=c(0,.7),   #   labels=c(\"MP-PCA\", \"None\")) +   geom_errorbar(     aes(ymax=group_mean_error+mean_rmse,          ymin=group_mean_error-mean_rmse,          width=0.7),      position=pd) +   facet_grid(motion.type~scheme) +    scale_fill_manual(     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")) +   theme_bw(     base_family=\"Helvetica\",     base_size=12   ) +   labs(title = \"Head Motion Estimate Error\",         y = \"Mean Error (±Mean RMSE)\",         x = \"Percent Motion Volumes\",         fill = \"Method\"#,        #pattern_alpha=\"Denoising\\nMethod\"        ) #+   #coord_fixed() #error_mean_plt # Summarize the motion rmse in the different cells rmse_plt <-  ggplot(     rmse_summaries,     aes(x=percent_motion,          y=mean_rmse,          fill=method,          pattern_alpha=denoising)) +   scale_pattern_type_discrete(     choices=c(\"hatch\")) +   geom_col_pattern(position=pd,                    width=0.5,                    pattern_spacing=0.03,                    pattern_fill=\"black\",                    color=\"black\") +   scale_pattern_alpha_discrete(     range=c(0,.7),     labels=c(\"MP-PCA\", \"None\")) +   geom_errorbar(     aes(ymax=mean_rmse+sd_rmse, ymin=mean_rmse-sd_rmse, width=0.7),      position=pd) +   facet_grid(motion.type~scheme) +    scale_fill_manual(     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")) +   theme_bw(     base_family=\"Helvetica\",     base_size=12   ) +   labs(title = \"Motion Estimate RMSE\",        y = \"Mean RMSE (±SD)\",         x = \"Percent Motion Volumes\",         fill = \"Method\",        pattern_alpha=\"Denoising\\nMethod\") +   coord_fixed() ## Warning: scale_pattern_alpha_discrete(): Using alpha for a discrete variable is ## not advised. #rmse_plt errs <- error_rmse %>% group_by(motion.type) %>%    summarise(mean_mean_error=mean(mean_error),             sd_mean_error=sd(mean_error)) tbl_summary(error_rmse, by = motion.type, statistic = list(all_continuous() ~ \"{mean} ({sd})\"), include = )"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"compare-performance-on-sampling-schemes","dir":"Articles","previous_headings":"Motion Analysis","what":"3. Compare Performance on Sampling Schemes","title":"Head Motion Benchmark","text":"4 sampling schemes compared . well motion correction methods work ? just another view previous plot, interesting clearly shows SHORELine’s performance 55-direction CS-DSI scan range performance ABCD multi shell scheme, almost twice many directions. Better statistically test sure: couple interesting results come along obvious ones. First, main effect number directions. directions, smaller RMSE.","code":"rmse_summaries_collapsed <- error_rmse %>%   group_by(scheme, motion.type, method, denoising) %>%   summarise(mean_rmse=mean(rmse),              sd_rmse=sd(rmse),              se_rmse=sd_rmse/sqrt(length(rmse)),             group_mean_error=mean(mean_error),             sd_mean_error=sd(mean_error)) %>%   mutate(denoised = recode(denoising, none=\"\", dwidenoise=\"+ MP-PCA\"),          method_name = paste(method, denoised)) %>%   select(-denoised) %>%   filter(method_name != \"SHORELine + MP-PCA\") # no difference, so skip it ## `summarise()` has grouped output by 'scheme', 'motion.type', 'method'. You can ## override using the `.groups` argument. rmse_summaries_collapsed$num_directions <- recode(   rmse_summaries_collapsed$scheme,   ABCD=103,   HCP=270,   DSIQ5=257,   HASC55=55)  rmse_summaries_collapsed$denoiser <- recode(   rmse_summaries_collapsed$denoising,   none=\"None\",   dwidenoise=\"MP-PCA\" )  rmse_summaries_collapsed$scheme_type = recode(   rmse_summaries_collapsed$scheme,   ABCD=\"Shelled\",   HCP=\"Shelled\",   DSIQ5=\"Non-Shelled\",   HASC55=\"Non-Shelled\")  rmse_summaries_collapsed$motion.type <- recode(   rmse_summaries_collapsed$motion.type,   Rotation=\"Rotation (degrees)\",   Translation=\"Translation (mm)\"   )  # Summarize the motion rmse in the different cells pd2 = position_dodge(8) directions_plt <-  ggplot(     rmse_summaries_collapsed,     aes(x=num_directions, y=mean_rmse,         color=method,         shape=scheme_type,         linetype=denoiser,         group=method_name)) +   geom_errorbar(     aes(ymax=mean_rmse+sd_rmse, ymin=mean_rmse-sd_rmse),      position=pd2) +   geom_point(size=2, position=pd2) +   geom_line() +   facet_grid(motion.type~.) +   theme_bw(     base_family=\"Helvetica\",     base_size=12   ) +   scale_color_manual(     labels=c(\"SHORELine\", \"Eddy\"),     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")) +   scale_linetype_manual(values=c(\"None\"=1,\"MP-PCA\" = 2)) +   labs(title = \"RMSE by Scheme Type\",         y = \"Mean RMSE (±SD)\",         x = \"Number of Directions\",         color = \"Method\",        linetype= \"Denoising\\nMethod\",        shape=\"Scheme\\nType\") #directions_plt error_rmse_dirs <- error_rmse  error_rmse_dirs$num_directions <- recode(   error_rmse_dirs$scheme,   ABCD=103,   HCP=270,   DSIQ5=257,   HASC55=55)  error_rmse_dirs$scheme_type = recode(   error_rmse_dirs$scheme,   ABCD=\"Shelled\",   HCP=\"Shelled\",   DSIQ5=\"Non-Shelled\",   HASC55=\"Non-Shelled\")  # Convert to percentage values error_rmse_dirs$percent_motion <- with(   error_rmse_dirs,   as.numeric(levels(percent_motion))[percent_motion])  rotation_shell_model <- lm(   rmse ~ scheme_type * num_directions + denoising + percent_motion,   data=subset(error_rmse_dirs, motion.type==\"Rotation\"))  translation_shell_model <- lm(   rmse ~ scheme_type * num_directions + denoising + percent_motion,   data=subset(error_rmse_dirs, motion.type==\"Translation\")) translation_rmse_tab <- tbl_regression(   translation_shell_model,    intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels()  rotation_rmse_tab <- tbl_regression(   rotation_shell_model,    intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels() tbl_merge(list(translation_rmse_tab, rotation_rmse_tab), tab_spanner = c(\"Translation\", \"Rotation\")) %>%   as_gt() %>%   fmt_number(n_sigfig = 2, matches(\"Beta\"), force_sign = TRUE) %>%   tab_header(title = \"RMSE of Predicted Motion\",              subtitle = \"Main Effects of Denoising, Number of Volumes, and Percent Motion, including interactions with Shell Scheme\") %>%   tab_source_note(md(\"*This data is simulated*\"))"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"head-to-head-comparison-of-shoreline-vs-eddy","dir":"Articles","previous_headings":"Motion Analysis","what":"4 Head to head comparison of SHORELine vs Eddy","title":"Head Motion Benchmark","text":"ABCD HCP sequences two schemes tested can processed Eddy SHORELine. Plot RMSE differences","code":"# Match the Eddy and SHORELine errors  paired_error <- error_rmse %>%   select(-mean_error, -sd_error) %>%   filter(scheme %in% c(\"ABCD\", \"HCP\")) %>%   spread(method, rmse, sep=\"_\") %>%    group_by(scheme, motion.type) %>%    mutate(shore_difference=method_Eddy - method_SHORELine,          percent_motion=as.numeric(levels(percent_motion))[percent_motion])  rotation_rmse_model_paired <- lm(   shore_difference ~ scheme * denoising * percent_motion,   data=subset(paired_error, motion.type==\"Rotation\"))  translation_rmse_model_paired <- lm(   shore_difference ~ scheme * denoising * percent_motion,   data=subset(paired_error, motion.type==\"Translation\")) translation_rmse_paired_tab <- tbl_regression(   translation_rmse_model_paired,    intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels()  rotation_rmse_paired_tab <- tbl_regression(   rotation_rmse_model_paired,    intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels() tbl_merge(list(translation_rmse_paired_tab, rotation_rmse_paired_tab), tab_spanner = c(\"Translation\", \"Rotation\")) %>%   as_gt() %>%   fmt_number(n_sigfig = 2, matches(\"Beta\"), force_sign = TRUE) %>%   tab_header(title = \"RMSE of Predicted Motion Using Paired Eddy & SHORELine Estimates\",              subtitle = \"Main Effects of Denoising & Percent Motion, and interactions with Shell Scheme\") %>%   tab_source_note(md(\"*This data is simulated*\")) paired_error$percent_motion <- factor(paired_error$percent_motion)  ggplot(paired_error,         aes(x=as.factor(percent_motion),             y=shore_difference,            fill=denoising)) +   geom_hline(yintercept = 0) +   geom_violin(draw_quantiles = 0.5) +    facet_grid(motion.type~scheme) +   scale_fill_manual(     labels=c(\"MP-PCA\", \"None\"),     values=c(\"dwidenoise\"=\"#FFC20A\", \"none\"=\"#0C7BDC\")) +   theme_bw(     base_family=\"Helvetica\",     base_size=12) +    labs(     title = \"Difference in Estimation Error (Eddy - SHORELine)\",     y = \"Estimation Error Difference\",     x = \"Percent Motion Volumes\",     fill=\"Denoising\\nMethod\")"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"qc-metric-comparisons-between-shoreline-and-eddy","dir":"Articles","previous_headings":"","what":"QC metric comparisons between SHORELine and Eddy","title":"Head Motion Benchmark","text":"accurately estimating head motion parameters important, head motion artifact present simulated data. factors like eddy current distortion can impact final quality results. therefore calculated compared Neighboring DWI Correlation (NDC) FWHM final outputs two methods. NDC FWHM results related, used method Cieslak et al. 2021 FWHM partialled NDC measurements.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"test-the-settings","dir":"Articles","previous_headings":"QC metric comparisons between SHORELine and Eddy","what":"1. Test the Settings","title":"Head Motion Benchmark","text":"tested settings see Linear/Quadratic Rigid/Affine made difference motion estimation accuracy. Linear/Quadratic showed difference, Rigid performed better Affine. Recall ’re testing NDC, better higher. t-tests work way : effects SHORELine estimates positive. means Affine NDC higher Rigid NDC. Although effects absolutely tiny, different direction RMSE tests: Affine produces higher QC metrics Rigid, Rigid accurate estimating head motion Affine. consistent tests, use Rigid QC comparisons. Rigid also remarkably faster Affine, first step powerful Eddy Current correction later.","code":"data(\"qc_df\") setting_tests <- qc_df %>%   rename(hmc_method=method) %>%   group_by(denoising, scheme, hmc_method, percent_motion) %>%   do(test = tidy(t.test(ndc.corrected ~ setting, data=., paired=TRUE))) %>%   unnest(test)  # Adjust the p-values and order them by the largest absolute effects setting_tests <- setting_tests %>%   mutate(p.value.adj = p.adjust(p.value)) #  # significant.effects <- subset(setting_tests, (p.value.adj < 0.01)) # significant.effects[order(-abs(significant.effects$estimate)),] qc_df <- subset(qc_df, setting %in% c(\"Rigid\", \"Quadratic\")) qc_df$setting <- NULL"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"how-does-the-fwhm-compare","dir":"Articles","previous_headings":"QC metric comparisons between SHORELine and Eddy","what":"How does the fwhm compare?","title":"Head Motion Benchmark","text":"","code":"fwhm_smooth_plot <- ggplot(qc_df, aes(x=factor(percent_motion), y=fwhm, fill=method)) +    geom_hline(yintercept = 0) +   geom_violin(draw_quantiles = 0.5) +    scale_fill_manual(     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")) +   theme_bw(     base_family=\"Helvetica\",     base_size=12   ) +   labs(title = \"Spatial Smoothness (FWHM)\",         y = \"FWHM (mm)\",         x = \"Percent Motion Volumes\",         fill = \"Method\") +   facet_grid(.~scheme) + ylim(3.5,4.5)  fwhm_smooth_plot ## Warning: Removed 4 rows containing missing values (geom_hline). ggsave(here(\"vignettes\",\"fwhm_smooth_plot.svg\"),        plot=fwhm_smooth_plot,        height=3,        width=7.9,        units=\"in\") ## Warning: Removed 4 rows containing missing values (geom_hline). # What about if we make a paired comparison? id_cols <- c(\"scheme\", \"iternum\", \"method\", \"denoising\", \"percent_motion\")  paired_fwhm <- qc_df %>%    select(one_of(c(id_cols, \"fwhm\"))) %>%   spread(method, fwhm, sep=\"_\") %>%   mutate(fwhm_diff=method_SHORELine - method_Eddy,          percent_motion = as.factor(percent_motion)) %>%   select(-starts_with(\"method_\")) fwhm_diff_model <- lm(   fwhm_diff ~ percent_motion + scheme + denoising,   data=paired_fwhm) tbl_regression(   fwhm_diff_model,   intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels() %>%   as_gt() %>%   tab_header(title = \"Linear Model Predicting FWHM (Eddy — Shoreline) of Each Scan\",              subtitle = \"Main Effects of Percent Motion, Scheme, and Denoising\") %>%   tab_source_note(md(\"*This data is simulated*\"))"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/articles/dmri_hmc_benchmark.html","id":"comparing-fwhm-corrected-ndc-between-shoreline-and-eddy","dir":"Articles","previous_headings":"QC metric comparisons between SHORELine and Eddy","what":"Comparing FWHM-corrected NDC between SHORELine and Eddy","title":"Head Motion Benchmark","text":"one methods higher NDC scores? Also improvement NDC relative raw data? know higher percent motion cause lower NDC scores unprocessed data.  NDC scores don’t mean much across sampling schemes, comparable within sampling schemes. top row shows MP-PCA improves NDC scores across board also Eddy small advantage two shelled schemes can used. second row shows percent improvement NDC relative raw scans. pretty remarkable. statistical tests, center raw NDC within percent motion category","code":"improved_ndc_summaries <- qc_df %>%   group_by(denoising, scheme, method, percent_motion) %>%   summarise(mean_ndc=mean(improved.ndc.corrected),              sd_ndc=sd(improved.ndc.corrected),              se_ndc=sd_ndc/sqrt(length(improved.ndc.corrected)),             group_mean_ndc=mean(mean_ndc),             sd_mean_ndc=sd(mean_ndc)) ## `summarise()` has grouped output by 'denoising', 'scheme', 'method'. You can ## override using the `.groups` argument. improved_ndc_summaries$measure <- 'NDC Change From Raw' ndc_summaries <- qc_df %>%   group_by(denoising, scheme, method, percent_motion) %>%   summarise(mean_ndc=mean(ndc.corrected),              sd_ndc=sd(ndc.corrected),              se_ndc=sd_ndc/sqrt(length(ndc.corrected)),             group_mean_ndc=mean(mean_ndc),             sd_mean_ndc=sd(mean_ndc)) ## `summarise()` has grouped output by 'denoising', 'scheme', 'method'. You can ## override using the `.groups` argument. ndc_summaries$measure <- 'Mean Preprocessed NDC' qc_summaries <- rbind(ndc_summaries, improved_ndc_summaries) qc_summaries$percent_motion <- as.factor(qc_summaries$percent_motion) pd=position_dodge(width=0.7, preserve=\"single\")  ndc_mean_plt <-  ggplot(     qc_summaries,     aes(x=percent_motion,          y=group_mean_ndc,          fill=method,          pattern_alpha=denoising)) +   scale_pattern_type_discrete(     choices=c(\"hatch\")) +   geom_col_pattern(position=pd,                    width=0.5,                    pattern_spacing=0.03,                    pattern_fill=\"black\",                    color=\"black\") +   scale_pattern_alpha_discrete(     range=c(0,.7),     labels=c(\"MP-PCA\", \"None\")) +   geom_errorbar(     aes(ymax=group_mean_ndc+sd_ndc, ymin=group_mean_ndc-sd_ndc, width=0.7),      position=pd) +   facet_grid(measure~scheme, scales = \"free_y\") +    scale_fill_manual(     values=c(\"SHORELine\"=\"#d95f02\", \"Eddy\"=\"#1b9e77\")) +   theme_bw(     base_family=\"Helvetica\",     base_size=12   ) +   labs(title = \"QC Measure\",         y = \"Neighboring DWI Correlation\",         x = \"Percent Motion Volumes\",        fill = \"Method\",        pattern_alpha=\"Denoising\\nMethod\") ## Warning: scale_pattern_alpha_discrete(): Using alpha for a discrete variable is ## not advised. ndc_mean_plt ggsave(here(\"vignettes\",\"ndc_mean_plot.svg\"),        plot=ndc_mean_plt,        height=3,        width=7.9,        units=\"in\") qc_df <- subset(qc_df, scheme %in% c(\"ABCD\", \"HCP\"))  ggplot(qc_df, aes(x=percent_motion, y=raw_neighbor_corr, color=scheme)) +    geom_jitter() +   ggtitle(\"Unprocessed data NDC values\") qc_df <- qc_df %>%    group_by(percent_motion) %>%    mutate(pct_motion_mean=median(raw_neighbor_corr),           centered_raw_ndc=raw_neighbor_corr - pct_motion_mean)  ggplot(qc_df, aes(x=percent_motion, y=centered_raw_ndc, color=scheme)) +    geom_jitter() +   ggtitle(\"Unprocessed data NDC values: Centered by percent motion\") paired_ndc <- qc_df %>%    select(one_of(c(id_cols, \"ndc.corrected\"))) %>%   spread(method, ndc.corrected, sep=\"_\") %>%   mutate(ndc_diff=method_SHORELine - method_Eddy) %>%   select(-starts_with(\"method_\"))  ndc_diff_model <- lm(   ndc_diff ~ percent_motion + denoising + scheme,   data=paired_ndc) tbl_regression(   ndc_diff_model,   intercept=TRUE,   estimate_fun = ~style_number(.x, digits=3)   ) %>%   bold_p() %>%   bold_labels() %>%    italicize_levels() %>%   as_gt() %>%   tab_header(title = \"NDC Model\") %>%   tab_source_note(md(\"*This data is simulated*\"))"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"First Last. Author, maintainer.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Last F (2022). SHORELINEPaper: Package (One Line, Title Case). R package version 0.0.0.9000, https://pennlinc.github.io/SHORELINE_PaperDemo/.","code":"@Manual{,   title = {SHORELINEPaper: What the Package Does (One Line, Title Case)},   author = {First Last},   year = {2022},   note = {R package version 0.0.0.9000},   url = {https://pennlinc.github.io/SHORELINE_PaperDemo/}, }"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/index.html","id":"shoreline-paper-reproducible-analysis","dir":"","previous_headings":"","what":"What the Package Does (One Line, Title Case)","title":"What the Package Does (One Line, Title Case)","text":"package developed reproduce, document, share results SHORELINE benchmarking paper developed Matt Cieslak Penn Lifespan Informatics & Neuroimaging Center (manuscript preparation). abstract paper reads follows: Head motion correction particularly challenging diffusion-weighted MRI (dMRI) scans due dramatic changes image contrast different gradient strengths directions. Currently head motion correction typically performed using Gaussian Process model implemented FSL’s Eddy. Recently, 3dSHORE-based SHORELine method introduced correct non-single-shelled sequence. perform comprehensive evaluation methods realistic simulations software fiber phantom known ground-truth head motion. demonstrate methods perform remarkably well, performance can affected sampling scheme, pervasiveness head motion denoising strategy applied head motion correction. package specifically documents statistical analysis portion paper. Articles, ’ll find Rmarkdown file produces statistical analysis dataset; walkthrough analyses performed; code producing visualizations table content. Dense code preprocessing datasets also available /R folder. can also reproduce analyses downloading package remotes::install_github(\"PennLINC/SHORELINE_PaperDemo\") emulating Article, online using Binder.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://pennlinc.github.io/SHORELINE_PaperDemo/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""}]
